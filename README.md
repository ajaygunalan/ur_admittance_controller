# ur_admittance_controller

6-DOF force-compliant motion control for Universal Robots with gravity compensation. See [docs/dependencies.md](docs/dependencies.md) for detailed package dependencies.


## Setup

Clone dependencies:
```bash
mkdir -p ~/ros2_ws/src && cd ~/ros2_ws/src
git clone https://github.com/ajaygunalan/ur_simulation_gz.git
git clone https://github.com/ajaygunalan/ur_admittance_controller.git
```

Install dependencies:
```bash
cd ~/ur_ws && rosdep install --from-paths src --ignore-src -r -y
```

Build simulation:
```bash
colcon build --packages-select ur_simulation_gz && source install/setup.bash
```

Build controller:
```bash
colcon build --packages-select ur_admittance_controller && source install/setup.bash
```

Build force sensor driver (if using hardware):

```
colcon build --packages-select netft_utils netft_interfaces
```


## Usage

### Simulation

Launch robot:
```bash
ros2 launch ur_simulation_gz ur_sim_control.launch.py ur_type:=ur5e
```

### Hardware Bringup (UR ROS 2 Driver)

**Prerequisites:**
- [Universal_Robots_ROS2_Driver](https://github.com/UniversalRobots/Universal_Robots_ROS2_Driver)

- [neft_utils](https://github.com/UTNuclearRoboticsPublic/netft_utils)
- [ros2_net_ft_driver](https://github.com/gbartyzel/ros2_net_ft_driver)


Network and connectivity

- Use a wired connection for reliability.
- Ensure the robot and your WSL/container IPs are on the same subnet.
- From inside the container, verify connectivity:
- On the teach pendant, open your External Control program and press Play to allow the controller to connect back to the driver.
- Check that topics are being published and that joint states are available

Launch robot and force sensor:

**Note:** Generate calibration file once with:

```bash
ros2 launch ur_calibration calibration_correction.launch.py \
  robot_ip:=169.254.120.1 target_filename:="$HOME/ur5e_calibration.yaml"
```


```bash
# Terminal 1: Launch UR5e driver
ros2 launch ur_robot_driver ur_control.launch.py \
  ur_type:=ur5e robot_ip:=169.254.120.1 \
  kinematics_params_file:="$HOME/ur5e_calibration.yaml"

# Terminal 2: Launch force sensor (with topic remapping)

```ros@asusrog:~/ros2_ws$ ros2 run netft_utils netft_node --address 169.254.120.10
```

Test robot connection:
```bash
ros2 run ur_robot_driver example_move.py
```

Initialize to equilibrium:
```bash
ros2 run ur_admittance_controller init_robot
```

Run calibration (one-time):
```bash
ros2 run ur_admittance_controller wrench_calibration_node
```

Switch controller:
```bash
ros2 control switch_controllers --deactivate scaled_joint_trajectory_controller --activate forward_velocity_controller
```

### Before Switching Controllers (Important)
Always ensure nothing is publishing to the velocity command topic before activating `forward_velocity_controller`. If a node (e.g., `admittance_node`) is still publishing, the robot may jump when the controller activates.

Check publishers:
```bash
ros2 topic info -v /forward_velocity_controller/commands
# Publisher count should be 0 before switching
```

If a publisher exists, identify and stop it:
```bash
# See the publishing node in the output above, or:
ros2 node list | rg admittance_node
ros2 node info /admittance_node

# Find and kill lingering processes (from any terminal/session)
pgrep -fa admittance_node
kill <PID>        # or: kill -9 <PID> if needed

# Re-check the topic has no publishers
ros2 topic info -v /forward_velocity_controller/commands
```

Only after Publisher count is 0, activate the velocity controller:
```bash
ros2 control switch_controllers --deactivate scaled_joint_trajectory_controller --activate forward_velocity_controller
```

Start wrench node:
```bash
ros2 run ur_admittance_controller wrench_node
```

Start admittance node:
```bash
ros2 run ur_admittance_controller admittance_node
```

### Force-Torque Topics

Quick checks while the wrench pipeline is running:
```bash
ros2 topic echo /netft/raw_sensor --once
ros2 topic echo /netft/proc_sensor --once
ros2 topic echo /netft/proc_probe --once
```
- `/netft/raw_sensor` streams the unfiltered wrench directly from the NetFT driver (sensor frame).
- `/netft/proc_sensor` publishes the low-pass filtered, gravity/bias compensated wrench (still in the sensor frame).
- `/netft/proc_probe` mirrors the compensated wrench after transforming it into the probe/tool frame.

## Architecture

```
[F/T Sensor] → [Wrench Node] → [Admittance Node] → [Robot]
                     ↓                ↓                ↓
            (Gravity Compensation) (M·ẍ+D·ẋ+K·x=F) (Velocity Commands)
```

### Core Components

- Init Robot: Moves to equilibrium, saves pose to config
- Wrench Calibration: Estimates gravity/bias parameters (LROM method)  
- Wrench Node: Compensates F/T data for gravity and transforms to base frame
- Admittance Node: Implements admittance control law, outputs joint velocities

### Key Files

- `config/equilibrium.yaml` - Robot equilibrium pose (generated by init_robot)
- `config/wrench_calibration.yaml` - Calibration parameters (generated by calibration)
- `config/admittance_config.yaml` - Control parameters (M/K/D matrices)

### Tips

See [docs/debugging.md](docs/debugging.md) for debugging with VS Code.
